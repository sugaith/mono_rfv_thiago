% !TeX encoding = UTF-8

\chapter{MATERIAIS E MÉTODOS}\label{ch:materiais-metodos}
Após os estudos realizados sobre processamento e classificação de imagens, sobre o algoritmo de detecção \textit{Haar-cascades} e o de reconhecimanto \textit{EigenFaces} contemplado no capítulo passado, é necessário definir o material e meio para desenvolver o sistema aqui proposto.

Este capítulo apresentará os materiais e metodos que serão utilizados para o desenvolvimento do sistema proposto neste trabalho.


\section{MATERIAIS}\label{sec: tec-ferramenta}
As seguintes seções irão detalhar os equipamentos que serão usados para o desenvolvimento do sistema e as tecnologias de software escolhidas baseado na revisão bibliográfica realizada e na experiência do autor.

\subsection{Hardwares}\label{sub-hardw}
Lista-se a seguir, os equipamentos necessários para a realização deste trabalho:

\begin{itemize}
	
	\item Câmera digital do tipo \textit{Web} (\textit{Webcam}) de 720p de resolução (ou 1280x720 \textit{pixels});
	\begin{itemize}
		\item será utilizada para captar o vídeo analógico e disponibilizá-lo no formato digital
	\end{itemize}

	\item Microcomputador pessoal com processador Intel i7, 32 gigabytes de memória, e placa de vídeo externa de 16 megabytes (alto rendimento);
	\begin{itemize}
		\item será utilizado como principal instrumento de desenvolvimento
	\end{itemize}
	
	\item Microcomputador pessoal do tipo notebook com processador Intel i3 de versão antiga, 2 gigabytes de memória, sem placa de vídeo externa, utilizando a própria memória RAM para renderização (baixo à médio rendimento);
	\begin{itemize}
		\item será utilizado como instrumento de desenvolvimento secundário, para testar questões de consumo de memória e processamento (desempenho)	
	\end{itemize}
	
\end{itemize}

Estes \textit{hadwares} são considerados suficientes para a realização deste trabalho.

\subsection{Softwares}\label{sub-softw}
As subseções seguintes irão citar e detalhar as tecnologias que serão utilizadas para a implementação do trabalho aqui proposto,  descrevendo a maneira que serão utilizados.

\subsubsection{Linguagem Java}\label{subsec:java}
A tecnologia Java é usada para desenvolver aplicativos para uma ampla variedade de ambientes, de dispositivos consumidores a sistemas corporativos heterogêneos \cite{ibm_java}. 

A linguagem Java deriva da linguagem C, portanto suas regras de sintaxe assemelham-se às regras de C. Por exemplo, os blocos de códigos são modularizados em métodos e delimitados por chaves ({ e }) e variáveis são declaradas antes que sejam usadas \cite{ibm_java}. 

Estruturalmente, a linguagem Java começa com pacotes. Um pacote é o mecanismo de \textit{namespace} da linguagem Java. Dentro dos pacotes estão as classes e dentro das classes estão métodos, variáveis, constantes e mais \cite{ibm_java}.

Java é uma linguagem Orientada a Objetos. A Programação Orientada a Objetos (POO) diz respeito a um padrão de desenvolvimento que consiste na representação de cada elemento em termos de um objeto, ou classe. Esse tipo de representação procura aproximar o sistema que está sendo criado ao que é observado no mundo real, e um objeto contém características e ações, assim como vemos na realidade \cite{dev_poo}. 

O Java possui classes prontas para a solução dos mais diversos problemas. A seguinte lista descreve as classes ou pacotes que este trabalho fará uso, dentre outras:

\begin{itemize}
	
	\item Pacote \textbf{\textit{java.swing}} e \textbf{\textit{java.awt}}: possui classes para a construção da interface (ou \textit{front-end}) do sistema. Botões, janelas, manipulação de eventos e outros componentes visuais;
	
	\item Pacote \textbf{\textit{java.io}}: utilizado para manipular entrada e saida de informações, manipulação de arquivos e pastas, etc;
	
	\item Pacote \textbf{\textit{java.util}}: possui classes de estrutura e manipulação de listas e filas, além uma variedade de classes úteis para problemas esporádicos;
	
	\item outros pacotes utilizados casualmente de acordo com a necessidade como o \textbf{\textit{java.lang}} provê classes que são fundamentais para a programação Java, por exemplo as classes de criação e execução de \textit{threads};	
	
\end{itemize}

\subsubsection{Biblioteca OpenCV, JavaCV e JavaCPP}\label{subsec:bib_opencv}

A biblioteca \textbf{OpenCV} (Open Source Computer Vision Library) foi originalmente desenvolvida pela Intel em 2000 e hoje é uma biblioteca multiplataforma, totalmente livre ao uso acadêmico e comercial, para o desenvolvimento de aplicativos na área de Visão computacional \cite{opencv}.

Seu código foi escrito em nas linguagens C e C++, porém possui interface para várias outras linguagens como Python, Visual Basic, Java, dentre outras. Incorpora algoritmos para a resolução de vários problemas na área de visão computacional, inclusive o algoritmo Haar-Cascades contemplados na \autoref{subsubsec:violajones}, o qual será utilizado.

A biblioteca \textbf{JavaCPP}, atualmente mantida pelo grupo ByteDeco, é considerada uma \textit{bridge} ("ponte") entre a linguagem C++ e Java, disponibilizando classes de configurações e interfaces para várias bibliotecas escritas em C++, inclusive a OpenCV \cite{javacpp}.

Por sua vez, a biblioteca \textbf{JavaCV},inicialmente desenvolvida pela Google e agora mantida pelo grupo ByteDeco, utiliza as interfaces e \textit{wrapers} da biblioteca JavaCPP e provê classes úteis que podem ser usadas para manipular a  OpenCV de maneira mais fácil para plataforma Java \cite{javacv}. Também oferece drivers de aceleração gráfica que otimizam o funcionamento da OpenCV na plataforma Java, dentre outras utilizades.

Estas três bibliotecas funcionam de maneira conjunta para resolver a problemática de aquisição, processamento de imagens, e classificação de objetos, e será utilizada neste trabalho.

A lista a seguir disponibiliza e detalha os principais pacotes, classes e métodos ou funções que se fará uso destas bibliotecas de desenvolvimento. As definições de suas funções foram retiradas das documentações dispostas nos \textit{links} de \cite{opencv}, \cite{javacv} e \cite{javacpp}: 

\begin{itemize}
	\item Pacotes/classes:
	\begin{itemize}
		\item \textit{\textbf{javacpp.opencv\_core.CvMemStorage}}: classe que representa um bloco de memória para armazenamento de vários componentes da OpenCV. Trata problemas alocação e desalocação de memória;
		
		\item \textbf{\textit{javacpp.opencv\_core.CvRect}}: esta classe é utilizada para representar um segmento de uma imagem com pontos x e y, altura e largura do segmento;
		
		\item \textbf{\textit{javacpp.opencv\_core.CvSeq}}: classe que representa uma lista (ou sequência) de classes do tipo \textit{CvRect};
		
		\item \textbf{\textit{javacpp.opencv\_core.IplImage}}: utilizada para representar uma imagem no fomrato \textit{raster};
		
		\item \textbf{\textit{javacv.VideoInputFrameGrabber}}:	classe responsável por estabelecer conexão com câmeras conectadas a um dispositivo (microcomputador, por exemplo);

		\item \textbf{\textit{javacv.FrameGrabber}}: esta classe tem a função de monitorar o fluxo de \textit{frames} de uma \textit{webcam} conectada a partir da classe \textit{VideoInputFrameGrabber} e disponibilizar uma imagem advinda deste fluxo quando requisitado;		
			
		\item \textbf{\textit{javacv.Java2DFrameConverter}}: tem a função de converter as classes de representações de imagens \textit{IplImage} e \textit{java.awt.image};
		
		\item \textbf{\textit{javacv.OpenCVFrameConverter}}: tem a função de converter as classes de representações de imagens \textit{IplImage} e \textit{javacv.Frame}, disponibilizada pela classe \textit{FrameGrabber} acima listada;
		
		\item \textbf{\textit{javacpp.opencv\_objdetect.CvHaarClassifierCascade}}: classe que contém as configurações e o algoritmo de classificação Haar-Cascades, utilizado para a detecção de objetos (ou faces);
	\end{itemize}

	\item Métodos ou funções:
	\begin{itemize}		
		\item \textbf{\textit{javacpp.opencv\_core.cvClearMemStorage}}: esta função desaloca o espaço de memória utilizada pela classe \textit{CvMemStorage} listada acima;
		
		\item \textbf{\textit{javacpp.opencv\_core.cvCreateImage}}: responsável por criar objetos da classe \textit{IplImage}, aceitando parâmetros como produndidade de cores, tamanho da imagem, dentro outros;
		
		\item \textbf{\textit{javacpp.opencv\_core.cvReleaseImage}}: este método libera o espaço de memória ocupado pelos objeto das classe \textit{IplImage};

		\item \textbf{\textit{javacpp.opencv\_core.cvGetSeqElem}}: manipula objetos da classe \textit{CvSeq} listada acima;
		
		\item \textbf{\textit{javacpp.opencv\_core.cvGetSize}}: função dispõe o tamanho em \textit{bytes} de um objeto das classes \textit{CvSeq}, \textit{CvRect} e \textit{IplImage};		
		
		\item \textbf{\textit{javacpp.opencv\_imgproc.cvCvtColor}}: função que tem a habilidade de mudar a disposição e profundidade de cores de uma imagem da classe \textit{IplImage}, por exemplo, convertendo-as em escala de cinza como contempla a \autoref{subsubsec:filtros};
		
		\item \textbf{\textit{javacpp.opencv\_imgproc.cvEqualizeHist}}: função com a habilidade de performar equalização de histograma, contemplada na \autoref{subsubsec:equalizacao};
		
		\item \textbf{\textit{javacpp.opencv\_imgproc.cvResize}}: função com a habilidade de escalonamento, contemplada na \autoref{subsubsec:escalonamento}

		\item \textbf{\textit{javacpp.helper.opencv\_objdetect.cvHaarDetectObjects}}: este método recebe um objeto configurado do tipo \textit{CvHaarClassifierCascade}, uma imagem do tipo \textit{IplImage}, dentre outros parâmetros, e efeticamente detecta objetos (no caso, face) na imagem retornando objetos da classe \textit{CvSeq} ou \textit{CvRect};
		
		\item outras funções ou métodos para manipular ou converter classes de objetos irão eventualmente ser utilizadas;
	\end{itemize}	
\end{itemize}

Estas três bibliotecas também possuem um conjunto de parâmetros e constantes pré estabelecidas para facilitar o estabelecimento do ambiente desenvolvimento que irão ser utilizadas.

\subsubsection{Biblioteca Colt}\label{subsec:bib_colt}
A biblioteca Colt foi desenvovida pela CERN (sigla francesa que corresponde à \textit{Conseil européen pour la recherche nucléaire}, em portugês Conselho Europeu de Pesquisas Nucleares) e provê uma gama de bibliotecas para Computação Científica e Técnica de Alta Performance em Java \cite{colt}. Será utilizada na implementação do algoritmo \textit{EigenFaces} para performar as operações necessárias descritas na \autoref{subsec:acp} e \autoref{subsec:acp-eigen}. Lista-se a seguir as classes que serão utilizadas desta biblioteca \cite{colt}:


\begin{itemize}
	\item \textbf{\textit{cern.colt.matrix.DoubleMatrix2D}}: uma classe abstrata para representrar matrizes de duas dimensões, contendo elementos do tipo primitivo \textit{double};
	
	\item \textbf{\textit{cern.colt.matrix.impl.DenseDoubleMatrix2D}}: uma classe que herda e implementa os métodos abstratos da classe \textit{DoubleMatrix2D} acima descrita. Possui métodos para clonar a matriz, reaver algum elemento, buscar algum elemento, conversão em vetores de \textit{double} po exemplo, dentre outras utilidades;
			
	\item \textbf{\textit{cern.jet.math.Functions}}:  contém classes métodos que definem funções matemáticas a serem aplicadas em matrizes como respresentam a classe \textit{DenseDoubleMatrix2D} acima citada, como soma, multiplicação, subtração de matrizes, etc;
	
	\item \textbf{\textit{cern.colt.matrix.linalg.EigenvalueDecomposition}}: classe que contém métodos para a extração dos \textit{eigenvalues} e \textit{eigenvectors} de uma matriz recebida, necessários para certas etapas do algorítio \textit{EigenFaces} descrito na \autoref{subsec:acp-eigen};
\end{itemize}		


\subsubsection{Sistema GIT}\label{subsec:git}
Git (uma gíria inglesa que referencia uma "pessoa teimosa") é um sistema de gerenciamento e controle de código livre criado pelos desenvolvedores Linus Tornalds (o criador do Sistema Operacional Linux) e Junio Hamano sob a licensa GNU (GPLv2) \cite{git}. Este sistema é extremamente útil para se ter cada etapa da escrita do código salva, com possibilidade de reversão de ações, criação de ramos de desenvolvimento dentre outras utilidades, e é utilizado tando na escrita desta monografia quanto na escrita do código do sistema de reconhecimento aqui proposto.

\subsubsection{NetBeans IDE}\label{subsec:netbeans}
O NetBeans é um IDE (\textit{Integrated Development Environment}, ou em português, Ambiente Integrado de Dezemvolvimento) livre licensiado pela \textit{Common Development and Distribution License} (CDDL) e \textit{GNU General Public License} (GPL).

Este editor de código tráz facilidades como auto-complemento de código, desenho visual de interface, atalhos de teclados para maior produtividade na escrita, \textit{debugger}, dentre outras vantagens, e foi escolhido para a implementação neste trabalho.

\subsubsection{Sistemas Linux e Windows}\label{subsec:linux}
O ambiente de desenvolvimento deste trabalho será configurado sob o sistema operacional Linux, que estará executando na máquina de alto rendimento descrita na \autoref{sub-hardw}, item "2". Já o sistema operacional Windows se executará na maquina de baixo à medio rendimento descrito também na \autoref{sub-hardw}, item "3", para testes. O sistema Linux é livre, e o sitema operacional Windows possui licensa para a máquina (\textit{notebook}) na qual estará sendo executada.


\section{Métodos}\label{sec:metodos}
O método define-se com um processo organizado, lógico e sistemático de pesquisa, instrução, desenvolvimento, etc \cite{dicio-metodo}. Existem vários métodos de pesquisa como o observacional, comparativo, histórico, experimental, dentre outros. Neste trabalho terá uma abordagem experimental, descrita na seção a seguir \cite{fachin-metodos}.


\subsection{Método Experimental}

No método experimental, variáveis são tratadas de maneira pré estabelecida e seus efeitos suficientemente controlados  e conhecidos pelos pesquisador. O princípio central da aplicação do método experimental é que deve-se aceitar os resultados como eles são apresentados, com tudo de imprevisto e acidental que possa haver diante dos resulatos obtidos, ignorando as próprias opiniões e também as alheias \cite{fachin-metodos}.

\subsection{Desenvolvimento Ágil}\label{subsec:devagil}
O Desenvolvimento Ágil foi padronizado pelo \textbf{Manifesto Ágil} como um método independente que reúne características de outras metodologias antigas as quais eram despadronizadas. Este manifesto foi criado para valorizar os seguintes pontos \cite{dev-agil}:

\begin{itemize}
	\item Indivíduos e suas interações são mais importantes que processos e ferramentas
	\item Software que funciona importa mais que uma documentação abrangente
	\item Colaboração com o cliente vale mais do que negociação de contratos
	\item Responder à mudanças é melhor do que seguir planos
\end{itemize}

No desenvolvimento ágil, os projetos adotam o modelo iterativo e em espiral (figura 1.5). Neste processo, as fases do projeto são executadas diversas vezes, produzindo ciclos curtos que se repetem ao longo de todo o desenvolvimento, sendo que, ao final de cada ciclo, sempre se tem um software funcional. Os ciclos são chamados de iterações e crescem em número de funcionalidades a cada repetição, sendo que, no último ciclo, todas as funcionalidades desejadas estariam implementadas, testadas e aprovadas \cite{dev-agil2}.

A \textbf{XP} (\textit{eXtremeProgramming}), explicada na seção seguinte, será utilizada neste projeto por ser incremental, focar-se no desenvolvimento ao invés da documentação e gerar, a cada iteração, um protótipo, essencial para testes, refinamento até que se chegue à um resultado satisfatório.

\subsubsection{XP (\textit{eXtremeProgramming})}

Apesar de ser uma metodologia dos anos 90, faz parte dos métodos ágeis, já que se encaixa no que define o que é um método ágil, conforme o Manifesto Ágil. Ela é baseada em três pilares: \textbf{agilidade no desenvolvimento, economia de recursos e qualidade do produto final} \cite{dev-agil2}.

\subsection{Modelagem UML}\label{subsec:uml}

A modelagem UML (\textit{Unified Modeling Language}, em português Linguagem de Modelagem Unificada), por vezes chamada de linguagem UML, procura fornecer meios para auxiliar no levantamento dos requisitos que irão constituir um sistema, além de recursos para a modelagem de estruturas que farão parte do mesmo. O fato da UML ser um padrão de grande aceitação no mercado também se deve, em grande parte, à forte integração desta com conceitos da Orientação a Objetos (OO) \cite{uml}. Como este trabalho propões a implementação na liguagem Java que é orientada a objetos, este padrão de modelagem será utilizado na elaboração de documentos modelando os componentes esperados para o funcionamento do sistema.

Dois dos diagramas que fazem parte da linguagem UML serão utilizados \cite{uml}:

\begin{itemize}
	\item Diagrama de Classes: Permite a visualização do conjunto de classes, detalhando atributos e operações (métodos) presentes, assim como prováveis relacionamentos entre essas estruturas. Considerado um diagrama estrutural;
	
	\item Diagrama de Sequência: Demonstra as interações entre diferentes objetos na execução de uma operação, destacando ainda a ordem em que tais ações acontecem num intervalo de tempo. A sequência em que as diversas operações são executadas ocorre na vertical, de cima para baixo. Considera,do um diagramas de interação;	
\end{itemize}

Estes dois diagramas serão utilizados para ilustrar as classes Java que serão implementadas, as interações de seus objetos e os processos do sistema que consiste na aquisição do vídeo, deteção e reconhecimento da face, ou seja, toda a entrada, processamento e saida de dados do sistema detalhando seus componentes e interações.

\section{Considerações Finais}\label{sec:consfin}
Neste capítulo foram abordados os materiais e métodos necessários para o desenvolvimento do sistema de reconhecimento de faces em vídeo, utilizando o algorítimo \textit{EigenFaces}. Pode-se destacar a modelagem que trará esclarecimento quanto à estrutura do sistema e ao processo que deve ser percorrido, o desenvolimento ágil considerado essencial para se ter resultados rápidos para que sejam analizados e iterados num ciclo de desenvolvimento espiral com melhoras a cada iteração. Outro destaque são as bibliotecas OpenCV, JavaCV e Colt, que juntamente com suas documentações facilitarão o processo de implementação do algorítimo \textit{eigenfaces} e o desenvolvimento do sistema como um todo e por fim, o sistema GIT que grava e assegura cada etapa do processo de escrita da monografia e do cógido.







%\codigoPython
%\lstinputlisting[label=cod:exempla-api, caption=Acesso à API do \textit{Twitter}]{src/acesso.py}





